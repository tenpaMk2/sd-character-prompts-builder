---
import {
  type Prompt,
  type Category,
  queryChildren,
} from "../libs/prompts-store";
import ColorButton from "./ColorButton.astro";
import PromptButton from "./PromptButton.astro";

interface Props {
  category: Category;
  parentPrompt: Prompt;
}

const { category, parentPrompt } = Astro.props;

const childLeafs = queryChildren(category, parentPrompt);
---

<parent-prompt data-category={category} data-parent={parentPrompt}>
  <button class="bar">{parentPrompt}</button>
  <div class="prompts-container hide">
    {
      childLeafs.map((leaf) => {
        switch (leaf.type) {
          case `parent-prompt`:
            return (
              <Astro.self category={category} parentPrompt={leaf.prompt} />
            );
          case `color-parent`:
            return <ColorButton colorCategory={leaf.colorCategory} />;
          case `child-prompt`:
            return (
              <PromptButton prompt={leaf.prompt}>{leaf.prompt}</PromptButton>
            );
        }
      })
    }
  </div>
</parent-prompt>

<script>
  import {
    promptEnableInfoStore,
    type Prompt,
    queryChildren,
    type Category,
    type UILeaf,
    colorCategoryTree,
  } from "../libs/prompts-store";

  class ParentPrompt extends HTMLElement {
    constructor() {
      super();

      const category = this.dataset.category as Category;
      const parentPrompt = this.dataset.parent as Prompt;

      const bar = this.querySelector(`button`);
      if (!bar) throw new Error("`button` is not found!!");

      bar.addEventListener(`click`, () => {
        const isEnable = promptEnableInfoStore.get()[parentPrompt];
        promptEnableInfoStore.setKey(parentPrompt, !isEnable);
      });

      promptEnableInfoStore.subscribe((info) => {
        const isEnable = info[parentPrompt];
        if (isEnable) {
          this.classList.add(`opening`);
        } else {
          this.classList.remove(`opening`);

          const disableRecursively = (leaf: UILeaf) => {
            switch (leaf.type) {
              case `parent-prompt`:
                promptEnableInfoStore.setKey(leaf.prompt, false);
                leaf.children.forEach(disableRecursively);
                return;
              case `child-prompt`:
                promptEnableInfoStore.setKey(leaf.prompt, false);
                return;
              case `color-parent`:
                for (const { prompt } of colorCategoryTree[
                  leaf.colorCategory
                ]) {
                  promptEnableInfoStore.setKey(prompt, false);
                }
                return;
            }
          };
          const children = queryChildren(category, parentPrompt);
          children.forEach(disableRecursively);
        }
      });
    }
  }

  customElements.define(`parent-prompt`, ParentPrompt);
</script>

<style>
  button {
    font-size: 1rem;
    border-radius: 0.5rem;
    padding: 0.4rem;
    cursor: pointer;
    background-color: transparent;
    outline: none;
    appearance: none;
    color: inherit;
    border-color: rgb(var(--text-main));
    width: 100%;
  }

  .hide {
    display: none;
  }

  parent-prompt {
    display: flex;
    flex-flow: column nowrap;
    gap: 1rem;
  }

  .opening > .bar {
    background-color: rgb(var(--accent));
    color: rgb(var(--text-main));
  }

  .opening > .prompts-container {
    display: grid;
    gap: 1rem;
    grid-template-columns: repeat(auto-fit, minmax(10rem, 1fr));
    grid-auto-flow: row dense;
  }
</style>
